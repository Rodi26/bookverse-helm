name: Update K8s

run-name: Platform Release ${{ github.event.client_payload.data.application_version }}

on:
  repository_dispatch:
    types: [release_completed]
  workflow_dispatch:
    inputs:
      platform_version:
        description: 'Platform version to pin (optional)'
        required: false
        type: string
      build_number:
        description: 'Optional build number fallback'
        required: false
        type: string

permissions:
  contents: write
  id-token: write

jobs:
  pin_and_package:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: "Debug: Log repository_dispatch event (console only)"
        if: github.event_name == 'repository_dispatch' && github.event.action == 'release_completed'
        run: |
          echo "Full repository_dispatch event (console log):"
          cat "$GITHUB_EVENT_PATH"

      - name: "Gate: only process PROD repository_dispatch events"
        run: |
          python - << 'PY'
          import json, os
          path=os.environ.get('GITHUB_EVENT_PATH')
          data=json.load(open(path)) if path and os.path.exists(path) else {}
          event_name=os.environ.get('GITHUB_EVENT_NAME','')
          action = data.get('action') or os.environ.get('GITHUB_EVENT_ACTION','')
          stage=''
          if event_name=='repository_dispatch':
            cp = (data.get('client_payload') or {}) if isinstance(data.get('client_payload'), dict) else {}
            stage = (cp.get('data') or {}).get('stage') or cp.get('stage') or ''
            # Fallback to top-level payload fields (e.g., JFrog webhook forwarded as-is)
            if not stage:
              top = (data.get('data') or {})
              stage = (top.get('stage') if isinstance(top, dict) else '') or data.get('stage') or ''
            # Default to PROD for JFrog release_completed if stage missing
            if not stage and str(action).lower()=='release_completed':
              stage='PROD'
            if str(stage).lower()!='prod':
              with open(os.environ['GITHUB_ENV'],'a') as f:
                f.write('SKIP=true\n')
              print(f"Skipping repository_dispatch: action={action!r}, stage={stage!r}")
            else:
              print("Proceeding: repository_dispatch for PROD")
          else:
            # Allow non-dispatch events (e.g., manual workflow_dispatch)
            print(f"Proceeding: non-dispatch event={event_name}")
          PY

      # (Removed payload summary here; a concise summary is produced in summarize_pins.)

      - name: Setup JFrog CLI (OIDC)
        if: env.SKIP != 'true'
        uses: EyalDelarea/setup-jfrog-cli@swampUpAppTrust
        with:
          version: latest

      - name: Configure JFrog CLI
        if: env.SKIP != 'true'
        env:
          JFROG_URL: ${{ vars.JFROG_URL }}
        run: |
          jf c add --interactive=false --url "${JFROG_URL}" --access-token ""
          jf c show
          jf rt ping

      - name: Set up Python
        if: env.SKIP != 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        if: env.SKIP != 'true'
        run: |
          python -m pip install --upgrade pip
          pip install PyYAML

      - name: Resolve platform version
        if: env.SKIP != 'true'
        id: resolve
        env:
          PLATFORM_APP: bookverse-platform
        run: |
          python - << 'PY'
          import os, json, re, subprocess, shlex
          app=os.environ.get('PLATFORM_APP','bookverse-platform')
          version=''
          # Try resolve from repository_dispatch payload
          ev_path=os.environ.get('GITHUB_EVENT_PATH','')
          if not version and ev_path and os.path.exists(ev_path):
              try:
                  ev=json.load(open(ev_path))
                  cp=ev.get('client_payload') if isinstance(ev.get('client_payload'), dict) else {}
                  if isinstance(cp, dict):
                      data = cp.get('data') if isinstance(cp.get('data'), dict) else {}
                      # Support snake_case and camelCase keys
                      version = (
                          data.get('application_version')
                          or data.get('applicationVersion')
                          or cp.get('platform_version')
                          or cp.get('platformVersion')
                          or cp.get('application_version')
                          or cp.get('applicationVersion')
                          or version
                      )
                      app = (
                          data.get('application_key')
                          or data.get('applicationKey')
                          or cp.get('application_key')
                          or cp.get('applicationKey')
                          or app
                      )
                  if not version:
                      top=ev.get('data') if isinstance(ev.get('data'), dict) else {}
                      version = (
                          (top.get('application_version') if isinstance(top, dict) else None)
                          or (top.get('applicationVersion') if isinstance(top, dict) else None)
                          or ev.get('platform_version')
                          or ev.get('platformVersion')
                          or ev.get('application_version')
                          or ev.get('applicationVersion')
                          or version
                      )
                      app = (
                          (top.get('application_key') if isinstance(top, dict) else None)
                          or (top.get('applicationKey') if isinstance(top, dict) else None)
                          or ev.get('application_key')
                          or ev.get('applicationKey')
                          or app
                      )
              except Exception:
                  pass
          # Validate version format from payload; treat invalid or placeholder as missing to trigger fallback
          if version:
              _pat = re.compile(r'^[A-Za-z0-9_][A-Za-z0-9_.\-+]*$')
              _v = str(version).strip()
              if _v == '<no value>' or not _pat.match(_v):
                  print(f"INFO: Ignoring invalid platform version from payload: {_v!r}")
                  version = ''
          if not version:
              # Fallback: try latest RELEASED; if that fails, try latest regardless of status
              def jf_rt_get(path: str):
                  try:
                      out = subprocess.check_output(shlex.split(f"jf rt curl -H Accept:application/json '{path}'"), stderr=subprocess.STDOUT)
                      txt = out.decode('utf-8','ignore')
                      try:
                          return json.loads(txt)
                      except Exception:
                          return {}
                  except subprocess.CalledProcessError as e:
                      print(f"WARN: jf rt curl failed: {e.output.decode('utf-8','ignore')[:300]}")
                      return {}
              payload = jf_rt_get(f"/apptrust/api/v1/applications/{app}/versions?limit=1&release_status=RELEASED") or \
                        jf_rt_get(f"/apptrust/api/v1/applications/{app}/versions?limit=1")
              if isinstance(payload, dict):
                  candidates = payload.get('results') or payload.get('data') or payload.get('items') or payload.get('versions') or []
              else:
                  candidates = payload
              # Pick first candidate with a valid version string according to allowed format
              def pick_valid(cands):
                  pattern = re.compile(r'^[A-Za-z0-9_][A-Za-z0-9_.\-+]*$')
                  for it in (cands or []):
                      val = it.get('version') or it.get('name') or ''
                      if val is None:
                          continue
                      v = str(val).strip()
                      if not v or v == '<no value>':
                          continue
                      if not pattern.match(v):
                          continue
                      return v
                  return ''
              version = pick_valid(candidates)
              if not version:
                  raise SystemExit('Unable to resolve a valid platform version from AppTrust')
          geh = os.environ.get('GITHUB_ENV')
          if geh:
              with open(geh, 'a', encoding='utf-8') as ef:
                  ef.write(f"RESOLVED_PV={version}\n")
                  ef.write(f"APPTRUST_APPLICATION={app}\n")
          print(f"Resolved platform version: {version}")
          PY

      - name: Fetch platform content from AppTrust (OIDC via JFrog CLI)
        if: env.SKIP != 'true'
        run: |
          set -euo pipefail
          echo "Fetching platform content for ${APPTRUST_APPLICATION}@${RESOLVED_PV}"
          jf rt curl -H "Accept: application/json" \
            "/apptrust/api/v1/applications/${APPTRUST_APPLICATION}/versions/${RESOLVED_PV}/content?include=releasables,sources" \
            > platform_components.json

      - name: Pin image tags in values.yaml
        if: env.SKIP != 'true'
        run: |
          python - << 'PY'
          import json, yaml, os
          comp=json.load(open('platform_components.json'))

          # Known app->values key mapping
          app_to_values_key={
            'bookverse-inventory':'inventory',
            'bookverse-recommendations':'recommendations',
            'bookverse-checkout':'checkout',
            'bookverse-web':'web',
          }

          def coalesce_keys(obj, *keys):
              for k in keys:
                  if isinstance(obj, dict) and k in obj and obj[k] not in (None, ''):
                      return obj[k]
              return None

          # 1) Extract component versions from sources.versions (preferred)
          versions_by_app={}
          src=(((comp or {}).get('sources') or {}).get('versions'))
          if isinstance(src, list):
              for entry in src:
                  ak = coalesce_keys(entry, 'application_key','applicationKey','application') or ''
                  ver = coalesce_keys(entry, 'application_version','applicationVersion','version')
                  if ak and ver:
                      versions_by_app[str(ak)]=str(ver)

          # 2) Also try to derive versions from releasables when available
          #    Many systems annotate each releasable with application_key and version
          rel = (comp or {}).get('releasables')
          if isinstance(rel, list):
              for item in rel:
                  props = coalesce_keys(item, 'properties','props','metadata','attributes') or {}
                  if not isinstance(props, dict):
                      props = {}
                  ak = (
                      coalesce_keys(item, 'application_key','applicationKey')
                      or coalesce_keys(props, 'application_key','applicationKey')
                      or ''
                  )
                  ver = (
                      coalesce_keys(item, 'application_version','applicationVersion','version')
                      or coalesce_keys(props, 'application_version','applicationVersion','version','docker.tag','image_tag')
                  )
                  if ak and ver and ak not in versions_by_app:
                      versions_by_app[str(ak)] = str(ver)

          # Helper to write tags into values
          def update_file(path):
            y=yaml.safe_load(open(path))
            # Set platform version if present in content
            plat_ver = coalesce_keys(comp, 'version','platform_version')
            if plat_ver is not None:
                y.setdefault('platform', {})['version']=str(plat_ver)

            # Map app->values keys (top-level services)
            decisions = []
            for app_key, values_key in app_to_values_key.items():
                ver = versions_by_app.get(app_key)
                if ver:
                    y.setdefault(values_key, {})['tag']=str(ver)
                    decisions.append(f"{values_key} <- {app_key}:{ver}")

            # Special case: recommendations.worker uses same app version unless a specific worker version exists
            rec_ver = versions_by_app.get('bookverse-recommendations')
            if rec_ver:
                y.setdefault('recommendations', {}).setdefault('worker', {})['tag']=str(rec_ver)
                decisions.append(f"recommendations.worker <- bookverse-recommendations:{rec_ver}")

            with open(path,'w') as f:
                yaml.safe_dump(y, f, sort_keys=False)

            # No summary output here; keep summary concise in summarize_pins

          # Update single values file only
          update_file('charts/platform/values.yaml')
          PY

      - name: Commit and push changes
        if: env.SKIP != 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add charts/platform/values.yaml platform_components.json || true
          if git diff --cached --quiet; then
            echo "No changes to commit"
            exit 0
          fi
          msg="chore(platform): update k8s pins for platform ${RESOLVED_PV}"
          git commit -m "$msg"
          git push

      - name: Setup Helm
        if: env.SKIP != 'true'
        uses: azure/setup-helm@v4
        with:
          version: v3.14.4

      - name: Helm lint and package
        if: env.SKIP != 'true'
        run: |
          helm lint charts/platform
          mkdir -p dist
          helm package charts/platform --destination dist

  summarize_pins:
    runs-on: ubuntu-latest
    needs: pin_and_package
    steps:
      - uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0
      - name: Ensure latest main
        run: |
          git fetch origin main --depth=1
          git checkout -qf origin/main
      - name: Summarize pinned image tags
        env:
          SKIP: ${{ needs.pin_and_package.outputs.SKIP || '' }}
        run: |
          python - << 'PY'
          import os, json, yaml

          def read_yaml(path):
              try:
                  with open(path, 'r', encoding='utf-8') as f:
                      return yaml.safe_load(f) or {}
              except Exception:
                  return {}

          def coalesce(obj, *keys):
              for k in keys:
                  if isinstance(obj, dict) and k in obj and obj[k] not in (None, ''):
                      return obj[k]
              return None

          # 1) Payload (concise)
          payload = {}
          ev_path=os.environ.get('GITHUB_EVENT_PATH')
          if ev_path and os.path.exists(ev_path):
              try:
                  ev=json.load(open(ev_path))
              except Exception:
                  ev={}
              cp=ev.get('client_payload') if isinstance(ev.get('client_payload'), dict) else {}
              data=cp.get('data') if isinstance(cp.get('data'), dict) else {}
              payload={
                  'application_key': data.get('application_key') or data.get('applicationKey') or cp.get('application_key') or cp.get('applicationKey') or '',
                  'application_version': data.get('application_version') or data.get('applicationVersion') or cp.get('application_version') or cp.get('applicationVersion') or '',
                  'stage': data.get('stage') or cp.get('stage') or ev.get('stage') or ''
              }

          # 2) Extracted component versions from platform_components.json
          versions_by_app = {}
          try:
              comp = json.load(open('platform_components.json'))
          except Exception:
              comp = {}
          src = (((comp or {}).get('sources') or {}).get('versions'))
          if isinstance(src, list):
              for entry in src:
                  ak = coalesce(entry, 'application_key','applicationKey','application')
                  ver = coalesce(entry, 'application_version','applicationVersion','version')
                  if ak and ver:
                      versions_by_app[str(ak)] = str(ver)
          rel = (comp or {}).get('releasables')
          if isinstance(rel, list):
              for item in rel:
                  props = coalesce(item, 'properties','props','metadata','attributes') or {}
                  if not isinstance(props, dict):
                      props = {}
                  ak = coalesce(item, 'application_key','applicationKey') or coalesce(props, 'application_key','applicationKey')
                  ver = coalesce(item, 'application_version','applicationVersion','version') or coalesce(props, 'application_version','applicationVersion','version','docker.tag','image_tag')
                  if ak and ver and ak not in versions_by_app:
                      versions_by_app[str(ak)] = str(ver)

          # 3) Pinned tags from values.yaml
          y = read_yaml('charts/platform/values.yaml')
          def get_tag(doc, svc):
              if svc == 'recommendations.worker':
                  return (((doc.get('recommendations') or {}).get('worker') or {}).get('tag')) or ''
              if svc == 'recommendations':
                  return ((doc.get('recommendations') or {}).get('tag')) or ''
              return ((doc.get(svc) or {}).get('tag')) or ''

          sections = []
          sections.append("### Payload")
          sections.append("""```json\n%s\n```""" % json.dumps(payload, indent=2, ensure_ascii=False))

          sections.append("### Extracted components")
          if versions_by_app:
              for k in sorted(versions_by_app.keys()):
                  sections.append(f"- {k}: {versions_by_app[k]}")
          else:
              sections.append("- (none found)")

          sections.append("### Pinned image tags")
          sections.append(f"platform.version = {(y.get('platform') or {}).get('version','')}")
          for svc in ['web','inventory','recommendations','checkout','recommendations.worker']:
              sections.append(f"- {svc}: tag={get_tag(y, svc)}")

          summary = os.environ.get('GITHUB_STEP_SUMMARY','')
          text = "\n".join(sections) + "\n"
          if summary:
              with open(summary, 'a', encoding='utf-8') as f:
                  f.write(text)
          else:
              print(text)
          PY


