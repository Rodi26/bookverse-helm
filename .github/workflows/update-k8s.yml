name: Update K8s

run-name: Platform Release ${{ github.event.client_payload.data.application_version }}

on:
  repository_dispatch:
    types: [release_completed]
  workflow_dispatch:
    inputs:
      platform_version:
        description: 'Platform version to pin (optional)'
        required: false
        type: string
      build_number:
        description: 'Optional build number fallback'
        required: false
        type: string

permissions:
  contents: write
  id-token: write

jobs:
  pin_and_package:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: "Debug: Log repository_dispatch event (console only)"
        if: github.event_name == 'repository_dispatch' && github.event.action == 'release_completed'
        run: |
          echo "Full repository_dispatch event (console log):"
          cat "$GITHUB_EVENT_PATH"

      - name: "Gate: only process PROD repository_dispatch events"
        run: |
          python - << 'PY'
          import json, os
          path=os.environ.get('GITHUB_EVENT_PATH')
          data=json.load(open(path)) if path and os.path.exists(path) else {}
          event_name=os.environ.get('GITHUB_EVENT_NAME','')
          action = data.get('action') or os.environ.get('GITHUB_EVENT_ACTION','')
          stage=''
          if event_name=='repository_dispatch':
            cp = (data.get('client_payload') or {}) if isinstance(data.get('client_payload'), dict) else {}
            stage = (cp.get('data') or {}).get('stage') or cp.get('stage') or ''
            if not stage:
              top = (data.get('data') or {})
              stage = (top.get('stage') if isinstance(top, dict) else '') or data.get('stage') or ''
            if not stage and str(action).lower()=='release_completed':
              stage='PROD'
            
            print(f"Debug: event_name={event_name}, action={action!r}, stage={stage!r}")
            print(f"Debug: client_payload keys: {list(cp.keys()) if isinstance(cp, dict) else 'not dict'}")
            if isinstance(cp, dict) and 'data' in cp:
              data_payload = cp['data']
              print(f"Debug: client_payload.data keys: {list(data_payload.keys()) if isinstance(data_payload, dict) else 'not dict'}")
            
            if str(stage).lower()!='prod':
              with open(os.environ['GITHUB_ENV'],'a') as f:
                f.write('SKIP=true\n')
              print(f"Skipping repository_dispatch: action={action!r}, stage={stage!r}")
            else:
              print("Proceeding: repository_dispatch for PROD")
          else:
            print(f"Proceeding: non-dispatch event={event_name}")
          PY


      - name: "[Setup] Checkout bookverse-infra for shared scripts"
        if: env.SKIP != 'true'
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository_owner }}/bookverse-infra
          path: bookverse-infra
          token: ${{ github.token }}

      - name: Setup JFrog CLI (OIDC)
        if: env.SKIP != 'true'
        uses: EyalDelarea/setup-jfrog-cli@swampUpAppTrust
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          JF_PROJECT: ${{ vars.PROJECT_KEY }}
          JFROG_CLI_BUILD_NAME: ${{ github.event.repository.name }}_${{ github.workflow }}_${{ github.job }}
          JFROG_CLI_BUILD_NUMBER: ${{ github.run_number }}-${{ github.run_attempt }}
        with:
          version: latest
          oidc-provider-name: bookverse-helm-github
          disable-job-summary: false
          disable-auto-build-publish: true
          disable-auto-evidence-collection: false
          oidc-audience: ${{ vars.JFROG_URL }}

      - name: "[Auth] OIDC Token Exchange (Shared Script)"
        if: env.SKIP != 'true'
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          PROJECT_KEY: ${{ vars.PROJECT_KEY }}
          PROVIDER_NAME: bookverse-helm-github
        run: |
          echo "🔐 Using shared OIDC authentication script for Helm deployment automation"
          chmod +x bookverse-infra/libraries/bookverse-devops/scripts/exchange-oidc-token.sh
          bookverse-infra/libraries/bookverse-devops/scripts/exchange-oidc-token.sh \
            --service-name "helm" \
            --provider-name "$PROVIDER_NAME" \
            --jfrog-url "$JF_URL" \
            --docker-registry "${{ vars.DOCKER_REGISTRY }}" \
            --verbose
          echo "✅ Shared OIDC authentication completed successfully"

      - name: Verify JFrog Authentication
        if: env.SKIP != 'true'
        run: |
          echo "🔐 Verifying JFrog CLI authentication and connectivity..."
          jf rt ping
          echo "✅ JFrog authentication successful"


      - name: Set up Python
        if: env.SKIP != 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        if: env.SKIP != 'true'
        run: |
          python -m pip install --upgrade pip
          pip install PyYAML

      - name: Resolve platform version
        if: env.SKIP != 'true'
        id: resolve
        env:
          PLATFORM_APP: bookverse-platform
          JFROG_URL: ${{ vars.JFROG_URL }}
          JF_OIDC_TOKEN: ${{ env.JF_OIDC_TOKEN }}
        run: |
          python - << 'PY'
          import os, json, re, urllib.request, urllib.error, urllib.parse
          app=os.environ.get('PLATFORM_APP','bookverse-platform')
          version=''
          ev_path=os.environ.get('GITHUB_EVENT_PATH','')
          if not version and ev_path and os.path.exists(ev_path):
              try:
                  ev=json.load(open(ev_path))
                  cp=ev.get('client_payload') if isinstance(ev.get('client_payload'), dict) else {}
                  if isinstance(cp, dict):
                      data = cp.get('data') if isinstance(cp.get('data'), dict) else {}
                      version = (
                          data.get('application_version')
                          or data.get('applicationVersion')
                          or cp.get('platform_version')
                          or cp.get('platformVersion')
                          or cp.get('application_version')
                          or cp.get('applicationVersion')
                          or version
                      )
                      app = (
                          data.get('application_key')
                          or data.get('applicationKey')
                          or cp.get('application_key')
                          or cp.get('applicationKey')
                          or app
                      )
                  if not version:
                      top=ev.get('data') if isinstance(ev.get('data'), dict) else {}
                      version = (
                          (top.get('application_version') if isinstance(top, dict) else None)
                          or (top.get('applicationVersion') if isinstance(top, dict) else None)
                          or ev.get('platform_version')
                          or ev.get('platformVersion')
                          or ev.get('application_version')
                          or ev.get('applicationVersion')
                          or version
                      )
                      app = (
                          (top.get('application_key') if isinstance(top, dict) else None)
                          or (top.get('applicationKey') if isinstance(top, dict) else None)
                          or ev.get('application_key')
                          or ev.get('applicationKey')
                          or app
                      )
              except Exception:
                  pass
          if version:
              _pat = re.compile(r'^[A-Za-z0-9_][A-Za-z0-9_.\-+]*$')
              _v = str(version).strip()
              if _v == '<no value>' or not _pat.match(_v):
                  print(f"INFO: Ignoring invalid platform version from payload: {_v!r}")
                  version = ''
          if not version:
              base=os.environ.get('JFROG_URL','').rstrip('/')
              token=os.environ.get('JF_OIDC_TOKEN','')
              if not base or not token:
                  raise SystemExit('Missing JFROG_URL or JF_OIDC_TOKEN')
              def http_get_json(url: str):
                  headers={"Authorization": f"Bearer {token}", "Accept": "application/json", "X-JFrog-Project": "bookverse"}
                  req=urllib.request.Request(url, headers=headers)
                  try:
                      with urllib.request.urlopen(req, timeout=30) as resp:
                          raw = resp.read().decode('utf-8') or '{}'
                      try:
                          return json.loads(raw)
                      except Exception:
                          return {}
                  except urllib.error.HTTPError as e:
                      body = ''
                      try:
                          body = e.read().decode('utf-8', 'ignore')
                      except Exception:
                          pass
                      print(f"WARN: GET {url} -> {e.code} {body[:200]}")
                      return {}
              base_q = f"{base}/apptrust/api/v1/applications/{urllib.parse.quote(app)}/versions?limit=1"
              payload = http_get_json(base_q + "&release_status=RELEASED") or http_get_json(base_q)
              if isinstance(payload, dict):
                  candidates = payload.get('results') or payload.get('data') or payload.get('items') or payload.get('versions') or []
              else:
                  candidates = payload
              def pick_valid(cands):
                  pattern = re.compile(r'^[A-Za-z0-9_][A-Za-z0-9_.\-+]*$')
                  for it in (cands or []):
                      val = it.get('version') or it.get('name') or ''
                      if val is None:
                          continue
                      v = str(val).strip()
                      if not v or v == '<no value>':
                          continue
                      if not pattern.match(v):
                          continue
                      return v
                  return ''
              version = pick_valid(candidates)
              if not version:
                  raise SystemExit('Unable to resolve a valid platform version from AppTrust')
          geh = os.environ.get('GITHUB_ENV')
          if geh:
              with open(geh, 'a', encoding='utf-8') as ef:
                  ef.write(f"RESOLVED_PV={version}\n")
                  ef.write(f"APPTRUST_APPLICATION={app}\n")
          print(f"Resolved platform version: {version}")
          PY

      - name: Fetch platform content from AppTrust
        if: env.SKIP != 'true'
        env:
          JFROG_URL: ${{ vars.JFROG_URL }}
          JF_OIDC_TOKEN: ${{ env.JF_OIDC_TOKEN }}
        run: |
          set -euo pipefail
          echo "Fetching platform content for ${APPTRUST_APPLICATION}@${RESOLVED_PV}"
          URL="${JFROG_URL%/}/apptrust/api/v1/applications/${APPTRUST_APPLICATION}/versions/${RESOLVED_PV}/content?include=releasables,sources"
          CODE=$(curl -sS -o platform_components.json -w "%{http_code}" \
            -H "Authorization: Bearer ${JF_OIDC_TOKEN}" \
            -H "X-JFrog-Project: ${{ vars.PROJECT_KEY }}" \
            -H "Accept: application/json" \
            "$URL")
          echo "Content fetch HTTP ${CODE}"

      - name: Pin image tags in values.yaml
        if: env.SKIP != 'true'
        run: |
          python - << 'PY'
          import json, yaml, os
          try:
              with open('platform_components.json', 'r', encoding='utf-8') as f:
                  raw = json.load(f)
          except Exception:
              raw = {}
          comp = raw if isinstance(raw, dict) else {}
          releasables = []
          if isinstance(raw, list):
              releasables = raw
          elif isinstance(comp.get('releasables'), list):
              releasables = comp.get('releasables')

          app_to_values_key={
            'bookverse-inventory':'inventory',
            'bookverse-recommendations':'recommendations',
            'bookverse-checkout':'checkout',
            'bookverse-web':'web',
          }

          def coalesce_keys(obj, *keys):
              for k in keys:
                  if isinstance(obj, dict) and k in obj and obj[k] not in (None, ''):
                      return obj[k]
              return None

          versions_by_app={}
          _sources = comp.get('sources') if isinstance(comp, dict) else None
          src = _sources.get('versions') if isinstance(_sources, dict) else None
          if isinstance(src, list):
              for entry in src:
                  ak = coalesce_keys(entry, 'application_key','applicationKey','application') or ''
                  ver = coalesce_keys(entry, 'application_version','applicationVersion','version')
                  if ak and ver:
                      versions_by_app[str(ak)]=str(ver)

          versions_by_service={}
          if isinstance(releasables, list):
              for item in releasables:
                  if not isinstance(item, dict):
                      continue
                  if item.get('package_type') != 'docker' or item.get('releasable_type') != 'package_version':
                      continue
                  name = str(item.get('name') or '').strip()
                  ver = str(item.get('version') or '').strip()
                  if name and ver:
                      versions_by_service[name] = ver

          def update_file(path):
            y=yaml.safe_load(open(path)) or {}
            plat_ver = coalesce_keys(comp, 'version','platform_version') if isinstance(comp, dict) else None
            if plat_ver is not None:
                y.setdefault('platform', {})['version']=str(plat_ver)

            name_map = {
              'web': ('web', None),
              'inventory': ('inventory', None),
              'recommendations': ('recommendations', None),
              'checkout': ('checkout', None),
              'recommendations-worker': ('recommendations', 'worker'),
            }
            for svc_name, (root, child) in name_map.items():
                ver = versions_by_service.get(svc_name)
                if ver:
                    if child:
                        y.setdefault(root, {}).setdefault(child, {})['tag']=str(ver)
                    else:
                        y.setdefault(root, {})['tag']=str(ver)

            for app_key, values_key in app_to_values_key.items():
                if values_key == 'recommendations':
                    if not ((y.get('recommendations') or {}).get('tag')):
                        ver = versions_by_app.get(app_key)
                        if ver:
                            y.setdefault('recommendations', {})['tag']=str(ver)
                    if not (((y.get('recommendations') or {}).get('worker') or {}).get('tag')):
                        verw = versions_by_service.get('recommendations-worker') or versions_by_app.get(app_key)
                        if verw:
                            y.setdefault('recommendations', {}).setdefault('worker', {})['tag']=str(verw)
                    continue
                if not ((y.get(values_key) or {}).get('tag')):
                    ver = versions_by_app.get(app_key)
                    if ver:
                        y.setdefault(values_key, {})['tag']=str(ver)

            with open(path,'w') as f:
                yaml.safe_dump(y, f, sort_keys=False)


          update_file('charts/platform/values.yaml')
          PY

      - name: Commit and push changes
        if: env.SKIP != 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add charts/platform/values.yaml platform_components.json || true
          if git diff --cached --quiet; then
            echo "No changes to commit"
            exit 0
          fi
          msg="chore(platform): update k8s pins for platform ${RESOLVED_PV}"
          git commit -m "$msg"
          git push

      - name: Setup Helm
        if: env.SKIP != 'true'
        uses: azure/setup-helm@v4
        with:
          version: v3.14.4

      - name: Helm lint and package
        if: env.SKIP != 'true'
        run: |
          helm lint charts/platform
          mkdir -p dist
          helm package charts/platform --destination dist

  summarize_pins:
    runs-on: ubuntu-latest
    needs: pin_and_package
    steps:
      - uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0
      - name: Ensure latest main
        run: |
          git fetch origin main --depth=1
          git checkout -qf origin/main
      - name: Summarize pinned image tags
        env:
          SKIP: ${{ needs.pin_and_package.outputs.SKIP || '' }}
        run: |
          python - << 'PY'
          import os, json, yaml

          def read_yaml(path):
              try:
                  with open(path, 'r', encoding='utf-8') as f:
                      return yaml.safe_load(f) or {}
              except Exception:
                  return {}

          def coalesce(obj, *keys):
              for k in keys:
                  if isinstance(obj, dict) and k in obj and obj[k] not in (None, ''):
                      return obj[k]
              return None

          payload = {}
          ev_path=os.environ.get('GITHUB_EVENT_PATH')
          if ev_path and os.path.exists(ev_path):
              try:
                  ev=json.load(open(ev_path))
              except Exception:
                  ev={}
              cp=ev.get('client_payload') if isinstance(ev.get('client_payload'), dict) else {}
              data=cp.get('data') if isinstance(cp.get('data'), dict) else {}
              payload={
                  'application_key': data.get('application_key') or data.get('applicationKey') or cp.get('application_key') or cp.get('applicationKey') or '',
                  'application_version': data.get('application_version') or data.get('applicationVersion') or cp.get('application_version') or cp.get('applicationVersion') or '',
                  'stage': (data.get('stage') or cp.get('stage') or ev.get('stage') or '').lower()
              }

          versions_by_app = {}
          versions_by_service = {}
          try:
              with open('platform_components.json','r',encoding='utf-8') as f:
                  raw = json.load(f)
          except Exception:
              raw = {}
          comp = raw if isinstance(raw, dict) else {}
          releasables = []
          if isinstance(raw, list):
              releasables = raw
          elif isinstance(comp.get('releasables'), list):
              releasables = comp.get('releasables')
          _sources = comp.get('sources') if isinstance(comp, dict) else None
          src = _sources.get('versions') if isinstance(_sources, dict) else None
          if isinstance(src, list):
              for entry in src:
                  ak = coalesce(entry, 'application_key','applicationKey','application')
                  ver = coalesce(entry, 'application_version','applicationVersion','version')
                  if ak and ver:
                      versions_by_app[str(ak)] = str(ver)
          if isinstance(releasables, list):
              for item in releasables:
                  if not isinstance(item, dict):
                      continue
                  if item.get('package_type') != 'docker' or item.get('releasable_type') != 'package_version':
                      continue
                  name = str(item.get('name') or '').strip()
                  ver = str(item.get('version') or '').strip()
                  if name and ver:
                      versions_by_service[name] = ver

          y = read_yaml('charts/platform/values.yaml')
          def get_tag(doc, svc):
              if svc == 'recommendations.worker':
                  return (((doc.get('recommendations') or {}).get('worker') or {}).get('tag')) or ''
              if svc == 'recommendations':
                  return ((doc.get('recommendations') or {}).get('tag')) or ''
              return ((doc.get(svc) or {}).get('tag')) or ''

          sections = []
          sections.append("### Payload")
          sections.append("""```json\n%s\n```""" % json.dumps(payload, indent=2, ensure_ascii=False))

          sections.append("### Extracted components")
          if versions_by_service:
              for k in sorted(versions_by_service.keys()):
                  sections.append(f"- {k}: {versions_by_service[k]}")
          elif versions_by_app:
              for k in sorted(versions_by_app.keys()):
                  sections.append(f"- {k}: {versions_by_app[k]}")
          else:
              sections.append("- (none found)")

          sections.append("### Pinned image tags")
          sections.append(f"platform.version = {(y.get('platform') or {}).get('version','')}")
          for svc in ['web','inventory','recommendations','checkout','recommendations.worker']:
              sections.append(f"- {svc}: tag={get_tag(y, svc)}")

          summary = os.environ.get('GITHUB_STEP_SUMMARY','')
          text = "\n".join(sections) + "\n"
          if summary:
              with open(summary, 'a', encoding='utf-8') as f:
                  f.write(text)
          else:
              print(text)
          PY


