name: Update K8s

on:
  repository_dispatch:
    types: [release_completed]
  workflow_dispatch:
    inputs:
      platform_version:
        description: 'Platform version to pin (optional)'
        required: false
        type: string
      build_number:
        description: 'Optional build number fallback'
        required: false
        type: string

permissions:
  contents: write

jobs:
  pin_and_package:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: "Debug: Dump full repository_dispatch event"
        if: github.event_name == 'repository_dispatch' && github.event.action == 'release_completed'
        run: |
          echo "### Full repository_dispatch event" >> "$GITHUB_STEP_SUMMARY"
          echo '```json' >> "$GITHUB_STEP_SUMMARY"
          cat "$GITHUB_EVENT_PATH" >> "$GITHUB_STEP_SUMMARY"
          echo '```' >> "$GITHUB_STEP_SUMMARY"
          echo "Full repository_dispatch event:"
          cat "$GITHUB_EVENT_PATH"

      - name: "Gate: only process PROD repository_dispatch events"
        run: |
          python - << 'PY'
          import json, os
          path=os.environ.get('GITHUB_EVENT_PATH')
          data=json.load(open(path)) if path and os.path.exists(path) else {}
          event_name=os.environ.get('GITHUB_EVENT_NAME','')
          action = data.get('action') or os.environ.get('GITHUB_EVENT_ACTION','')
          stage=''
          if event_name=='repository_dispatch':
            cp = (data.get('client_payload') or {}) if isinstance(data.get('client_payload'), dict) else {}
            stage = (cp.get('data') or {}).get('stage') or cp.get('stage') or ''
            # Fallback to top-level payload fields (e.g., JFrog webhook forwarded as-is)
            if not stage:
              top = (data.get('data') or {})
              stage = (top.get('stage') if isinstance(top, dict) else '') or data.get('stage') or ''
            # Default to PROD for JFrog release_completed if stage missing
            if not stage and str(action).lower()=='release_completed':
              stage='PROD'
            if str(stage).lower()!='prod':
              with open(os.environ['GITHUB_ENV'],'a') as f:
                f.write('SKIP=true\n')
              print(f"Skipping repository_dispatch: action={action!r}, stage={stage!r}")
            else:
              print("Proceeding: repository_dispatch for PROD")
          else:
            # Allow non-dispatch events (e.g., manual workflow_dispatch)
            print(f"Proceeding: non-dispatch event={event_name}")
          PY

      - name: Add webhook payload to job summary
        if: env.SKIP != 'true' && github.event_name == 'repository_dispatch' && github.event.action == 'release_completed'
        run: |
          python - << 'PY'
          import os, json
          path=os.environ.get('GITHUB_EVENT_PATH')
          summary=os.environ.get('GITHUB_STEP_SUMMARY','')
          data={}
          if path and os.path.exists(path):
              try:
                  with open(path, 'r', encoding='utf-8') as f:
                      data=json.load(f)
              except Exception as e:
                  data={"error": f"failed to load event payload: {e}"}
          body={}
          if isinstance(data, dict):
              cp=data.get('client_payload')
              if isinstance(cp, dict):
                  if isinstance(cp.get('data'), dict):
                      body = cp.get('data')
                  else:
                      body = cp
              if not body:
                  if isinstance(data.get('data'), dict):
                      body=data.get('data')
                  else:
                      body=data
          lines=["### Webhook payload","","```json", json.dumps(body, indent=2, ensure_ascii=False), "```",""]
          if summary:
              with open(summary, 'a', encoding='utf-8') as f:
                  f.write("\n".join(lines))
          else:
              print("\n".join(lines))
          PY

      - name: Derive AppTrust context
        if: env.SKIP != 'true'
        env:
          JFROG_URL: ${{ vars.JFROG_URL }}
          JFROG_TOKEN: ${{ secrets.JFROG_ADMIN_TOKEN || secrets.JFROG_ACCESS_TOKEN }}
        run: |
          BASE="${JFROG_URL%/}"
          if [[ -z "${BASE}" ]]; then echo "Missing vars.JFROG_URL" >&2; exit 1; fi
          if [[ -z "${JFROG_TOKEN}" ]]; then echo "Missing JFROG token (admin or access)" >&2; exit 1; fi
          echo "APPTRUST_BASE_URL=${BASE}/apptrust/api/v1" >> "$GITHUB_ENV"
          echo "APPTRUST_ACCESS_TOKEN=${JFROG_TOKEN}" >> "$GITHUB_ENV"

      - name: Set up Python
        if: env.SKIP != 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        if: env.SKIP != 'true'
        run: |
          python -m pip install --upgrade pip
          pip install PyYAML

      - name: Resolve platform components from AppTrust
        if: env.SKIP != 'true'
        id: resolve
        env:
          PLATFORM_APP: bookverse-platform
        run: |
          python - << 'PY'
          import os, json, urllib.request, urllib.parse, re
          base=os.environ.get('APPTRUST_BASE_URL','').rstrip('/')
          token=os.environ.get('APPTRUST_ACCESS_TOKEN','')
          app=os.environ.get('PLATFORM_APP','bookverse-platform')
          version=''
          # Try resolve from repository_dispatch payload
          ev_path=os.environ.get('GITHUB_EVENT_PATH','')
          if not version and ev_path and os.path.exists(ev_path):
              try:
                  ev=json.load(open(ev_path))
                  cp=ev.get('client_payload') if isinstance(ev.get('client_payload'), dict) else {}
                  if isinstance(cp, dict):
                      data = cp.get('data') if isinstance(cp.get('data'), dict) else {}
                      # Support snake_case and camelCase keys
                      version = (
                          data.get('application_version')
                          or data.get('applicationVersion')
                          or cp.get('platform_version')
                          or cp.get('platformVersion')
                          or cp.get('application_version')
                          or cp.get('applicationVersion')
                          or version
                      )
                      app = (
                          data.get('application_key')
                          or data.get('applicationKey')
                          or cp.get('application_key')
                          or cp.get('applicationKey')
                          or app
                      )
                  if not version:
                      top=ev.get('data') if isinstance(ev.get('data'), dict) else {}
                      version = (
                          (top.get('application_version') if isinstance(top, dict) else None)
                          or (top.get('applicationVersion') if isinstance(top, dict) else None)
                          or ev.get('platform_version')
                          or ev.get('platformVersion')
                          or ev.get('application_version')
                          or ev.get('applicationVersion')
                          or version
                      )
                      app = (
                          (top.get('application_key') if isinstance(top, dict) else None)
                          or (top.get('applicationKey') if isinstance(top, dict) else None)
                          or ev.get('application_key')
                          or ev.get('applicationKey')
                          or app
                      )
              except Exception:
                  pass
          # Validate version format from payload; treat invalid or placeholder as missing to trigger fallback
          if version:
              _pat = re.compile(r'^[A-Za-z0-9_][A-Za-z0-9_.\-+]*$')
              _v = str(version).strip()
              if _v == '<no value>' or not _pat.match(_v):
                  print(f"INFO: Ignoring invalid platform version from payload: {_v!r}")
                  version = ''
          if not base or not token:
              raise SystemExit('Missing AppTrust base URL or token')
          if not version:
              # Fallback: try latest RELEASED; if that fails, try latest regardless of status
              import urllib.error
              def fetch_versions(url: str):
                  req=urllib.request.Request(url, headers={"Authorization": f"Bearer {token}", "Accept": "application/json"})
                  try:
                      with urllib.request.urlopen(req, timeout=30) as resp:
                          raw = resp.read().decode('utf-8') or '[]'
                      try:
                          return json.loads(raw)
                      except Exception:
                          return []
                  except urllib.error.HTTPError as e:
                      body = ''
                      try:
                          body = e.read().decode('utf-8', 'ignore')
                      except Exception:
                          pass
                      print(f"WARN: versions query failed {e.code} for {url} -> {body[:300]}")
                      return []
              base_url=f"{base}/applications/{urllib.parse.quote(app)}/versions?limit=1"
              payload = fetch_versions(base_url + "&release_status=RELEASED")
              if not payload:
                  payload = fetch_versions(base_url)
              if isinstance(payload, dict):
                  candidates = payload.get('results') or payload.get('data') or payload.get('items') or payload.get('versions') or []
              else:
                  candidates = payload
              # Pick first candidate with a valid version string according to allowed format
              def pick_valid(cands):
                  pattern = re.compile(r'^[A-Za-z0-9_][A-Za-z0-9_.\-+]*$')
                  for it in (cands or []):
                      val = it.get('version') or it.get('name') or ''
                      if val is None:
                          continue
                      v = str(val).strip()
                      if not v or v == '<no value>':
                          continue
                      if not pattern.match(v):
                          continue
                      return v
                  return ''
              version = pick_valid(candidates)
              if not version:
                  raise SystemExit('Unable to resolve a valid platform version from AppTrust')
          if not version:
              raise SystemExit('Missing PLATFORM_VERSION (payload or fallback)')
          url=f"{base}/applications/{urllib.parse.quote(app)}/versions/{urllib.parse.quote(version)}/content?include=releasables"
          req=urllib.request.Request(url, headers={"Authorization": f"Bearer {token}", "Accept": "application/json"})
          try:
              with urllib.request.urlopen(req, timeout=60) as resp:
                  data=json.loads(resp.read().decode('utf-8') or '{}')
          except urllib.error.HTTPError as e:
              body = ''
              try:
                  body = e.read().decode('utf-8', 'ignore')
              except Exception:
                  pass
              raise SystemExit(f"Failed to fetch platform content for version {version}: {e.code} {body[:300]}")
          with open('platform_components.json','w', encoding='utf-8') as f:
              json.dump(data, f)
          geh = os.environ.get('GITHUB_ENV')
          if geh:
              with open(geh, 'a', encoding='utf-8') as ef:
                  ef.write(f"RESOLVED_PV={version}\n")
          print(f"Resolved platform version: {version}")
          PY

      - name: Pin image tags in values.yaml
        if: env.SKIP != 'true'
        run: |
          python - << 'PY'
          import json, yaml
          comp=json.load(open('platform_components.json'))
          # For demo simplicity, assume we know mapping service->values keys
          mapping={
            'bookverse-inventory':'inventory',
            'bookverse-recommendations':'recommendations',
            'bookverse-checkout':'checkout',
            'bookverse-web':'web',
          }
          # Extract versions from sources.versions if present
          versions={}
          src=comp.get('sources',{}).get('versions',[])
          if isinstance(src, list):
              for v in src:
                  ak=v.get('application_key') or v.get('application') or ''
                  ver=v.get('version')
                  if ak and ver:
                      versions[ak]=ver
          def update_file(path):
            y=yaml.safe_load(open(path))
            plat_ver = comp.get('version') or comp.get('platform_version')
            if plat_ver is not None:
                y.setdefault('platform', {})['version']=str(plat_ver)
            for ak,svc in mapping.items():
                ver=versions.get(ak)
                if ver:
                    y.setdefault(svc, {})['tag']=str(ver)
            with open(path,'w') as f:
                yaml.safe_dump(y, f, sort_keys=False)
          # Update single values file only
          update_file('charts/platform/values.yaml')
          PY

      - name: Commit and push changes
        if: env.SKIP != 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add charts/platform/values.yaml platform_components.json || true
          if git diff --cached --quiet; then
            echo "No changes to commit"
            exit 0
          fi
          msg="chore(platform): update k8s pins for platform ${RESOLVED_PV}"
          git commit -m "$msg"
          git push

      - name: Setup Helm
        if: env.SKIP != 'true'
        uses: azure/setup-helm@v4
        with:
          version: v3.14.4

      - name: Helm lint and package
        if: env.SKIP != 'true'
        run: |
          helm lint charts/platform
          mkdir -p dist
          helm package charts/platform --destination dist

  summarize_pins:
    runs-on: ubuntu-latest
    needs: pin_and_package
    steps:
      - uses: actions/checkout@v4
      - name: Summarize pinned image tags
        env:
          SKIP: ${{ needs.pin_and_package.outputs.SKIP || '' }}
        run: |
          python - << 'PY'
          import os, yaml
          def read_yaml(path):
              try:
                  with open(path, 'r', encoding='utf-8') as f:
                      return yaml.safe_load(f) or {}
              except Exception:
                  return {}
          y = read_yaml('charts/platform/values.yaml')
          def get_tag(doc, svc):
              if svc == 'recommendations.worker':
                  return (((doc.get('recommendations') or {}).get('worker') or {}).get('tag')) or ''
              if svc == 'recommendations':
                  return ((doc.get('recommendations') or {}).get('tag')) or ''
              return ((doc.get(svc) or {}).get('tag')) or ''
          lines = []
          for svc in ['web','inventory','recommendations','checkout','recommendations.worker']:
              lines.append(f"- {svc}: tag={get_tag(y, svc)}")
          body = [
              "### Pinned image tags",
              f"platform.version = {(y.get('platform') or {}).get('version','')}",
              "",
              *lines,
          ]
          summary = os.environ.get('GITHUB_STEP_SUMMARY','')
          if summary:
              with open(summary, 'a', encoding='utf-8') as f:
                  f.write("\n".join(body) + "\n")
          else:
              print("\n".join(body))
          PY


