name: Update K8s

run-name: Platform Release ${{ github.event.client_payload.data.application_version }}

on:
  repository_dispatch:
    types: [release_completed]
  workflow_dispatch:
    inputs:
      platform_version:
        description: 'Platform version to pin (optional)'
        required: false
        type: string
      build_number:
        description: 'Optional build number fallback'
        required: false
        type: string

permissions:
  contents: write
  id-token: write

jobs:
  pin_and_package:
    runs-on: ubuntu-latest
    outputs:
      SKIP: ${{ env.SKIP }}
      SKIP_REASON: ${{ env.SKIP_REASON }}
    steps:
      - uses: actions/checkout@v4

      - name: "Debug: Log repository_dispatch event (console only)"
        if: github.event_name == 'repository_dispatch' && github.event.action == 'release_completed'
        run: |
          echo "Full repository_dispatch event (console log):"
          cat "$GITHUB_EVENT_PATH"

      - name: "Gate: only process PROD repository_dispatch events"
        run: |
          python - << 'PY'
          import json, os
          path=os.environ.get('GITHUB_EVENT_PATH')
          data=json.load(open(path)) if path and os.path.exists(path) else {}
          event_name=os.environ.get('GITHUB_EVENT_NAME','')
          action = data.get('action') or os.environ.get('GITHUB_EVENT_ACTION','')
          stage=''
          if event_name=='repository_dispatch':
            cp = (data.get('client_payload') or {}) if isinstance(data.get('client_payload'), dict) else {}
            stage = (cp.get('data') or {}).get('stage') or cp.get('stage') or ''
            if not stage:
              top = (data.get('data') or {})
              stage = (top.get('stage') if isinstance(top, dict) else '') or data.get('stage') or ''
            if not stage and str(action).lower()=='release_completed':
              stage='PROD'
            
            app_key = ''
            if isinstance(cp, dict) and 'data' in cp:
              data_payload = cp['data']
              if isinstance(data_payload, dict):
                app_key = data_payload.get('application_key') or data_payload.get('applicationKey') or ''
            
            print(f"Debug: event_name={event_name}, action={action!r}, stage={stage!r}, app_key={app_key!r}")
            print(f"Debug: client_payload keys: {list(cp.keys()) if isinstance(cp, dict) else 'not dict'}")
            print(f"Debug: client_payload content: {cp if isinstance(cp, dict) else 'not dict'}")
            if isinstance(cp, dict) and 'data' in cp:
              data_payload = cp['data']
              print(f"Debug: client_payload.data keys: {list(data_payload.keys()) if isinstance(data_payload, dict) else 'not dict'}")
              print(f"Debug: client_payload.data content: {data_payload if isinstance(data_payload, dict) else 'not dict'}")
            
            should_skip = False
            skip_reason = ""
            
            if str(stage).lower() != 'prod':
              should_skip = True
              skip_reason = f"stage is {stage!r}, not PROD"
            elif app_key and str(app_key).lower() != 'bookverse-platform':
              should_skip = True 
              skip_reason = f"application_key is {app_key!r}, not bookverse-platform"
            
            if should_skip:
              with open(os.environ['GITHUB_ENV'],'a') as f:
                f.write('SKIP=true\n')
                f.write(f'SKIP_REASON={skip_reason}\n')
              print(f"Skipping repository_dispatch: {skip_reason}")
            else:
              print("Proceeding: repository_dispatch for PROD bookverse-platform")
          else:
            print(f"Proceeding: non-dispatch event={event_name}")
          PY


      - name: "[Setup] Checkout bookverse-infra for shared scripts"
        if: env.SKIP != 'true'
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository_owner }}/bookverse-infra
          path: bookverse-infra
          token: ${{ github.token }}

      - name: Setup JFrog CLI (OIDC)
        if: env.SKIP != 'true'
        uses: EyalDelarea/setup-jfrog-cli@swampUpAppTrust
        id: jfrog-cli-auth
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          JF_PROJECT: ${{ vars.PROJECT_KEY }}
          JFROG_CLI_BUILD_NAME: ${{ github.event.repository.name }}_${{ github.workflow }}_${{ github.job }}
          JFROG_CLI_BUILD_NUMBER: ${{ github.run_number }}-${{ github.run_attempt }}
        with:
          version: latest
          oidc-provider-name: bookverse-helm-github
          disable-job-summary: false
          disable-auto-build-publish: true
          disable-auto-evidence-collection: false
          oidc-audience: ${{ vars.JFROG_URL }}

      - name: "[Setup] Extract OIDC Token from JFrog CLI"
        if: env.SKIP != 'true'
        id: extract-token
        run: |
          echo "üîç Extracting OIDC token from JFrog CLI step output..."
          
          OIDC_TOKEN="${{ steps.jfrog-cli-auth.outputs.oidc-token }}"
          if [[ -n "$OIDC_TOKEN" && "$OIDC_TOKEN" != "null" ]]; then
            echo "‚úÖ Successfully retrieved OIDC token from JFrog CLI step output (oidc-token)"
            echo "üìã Token length: ${
            echo "JF_OIDC_TOKEN=$OIDC_TOKEN" >> $GITHUB_ENV
          else
            echo "‚ùå OIDC token not available from JFrog CLI step output (oidc-token)"
            echo "üîç Available outputs from jfrog-cli-auth step:"
            echo "  oidc-user: '${{ steps.jfrog-cli-auth.outputs.oidc-user }}'"
            echo "  oidc-token: '${{ steps.jfrog-cli-auth.outputs.oidc-token }}'"
            echo "  token: '${{ steps.jfrog-cli-auth.outputs.token }}'"
            exit 1
          fi

      - name: Verify JFrog Authentication
        if: env.SKIP != 'true'
        run: |
          echo "üîê Verifying JFrog CLI authentication and connectivity..."
          jf rt ping
          echo "‚úÖ JFrog authentication successful"


      - name: Set up Python
        if: env.SKIP != 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        if: env.SKIP != 'true'
        run: |
          python -m pip install --upgrade pip
          pip install PyYAML

      - name: Resolve platform version
        if: env.SKIP != 'true'
        id: resolve
        env:
          PLATFORM_APP: bookverse-platform
          JFROG_URL: ${{ vars.JFROG_URL }}
          JF_OIDC_TOKEN: ${{ env.JF_OIDC_TOKEN }}
          PROJECT_KEY: ${{ vars.PROJECT_KEY }}
        run: |
          python - << 'PY'
          import os, json, re, urllib.request, urllib.error, urllib.parse
          app=os.environ.get('PLATFORM_APP','bookverse-platform')
          version=''
          ev_path=os.environ.get('GITHUB_EVENT_PATH','')
          if not version and ev_path and os.path.exists(ev_path):
              try:
                  ev=json.load(open(ev_path))
                  cp=ev.get('client_payload') if isinstance(ev.get('client_payload'), dict) else {}
                  if isinstance(cp, dict):
                      data = cp.get('data') if isinstance(cp.get('data'), dict) else {}
                      version = (
                          data.get('application_version')
                          or data.get('applicationVersion')
                          or cp.get('platform_version')
                          or cp.get('platformVersion')
                          or cp.get('application_version')
                          or cp.get('applicationVersion')
                          or version
                      )
                      app = (
                          data.get('application_key')
                          or data.get('applicationKey')
                          or cp.get('application_key')
                          or cp.get('applicationKey')
                          or app
                      )
                  if not version:
                      top=ev.get('data') if isinstance(ev.get('data'), dict) else {}
                      version = (
                          (top.get('application_version') if isinstance(top, dict) else None)
                          or (top.get('applicationVersion') if isinstance(top, dict) else None)
                          or ev.get('platform_version')
                          or ev.get('platformVersion')
                          or ev.get('application_version')
                          or ev.get('applicationVersion')
                          or version
                      )
                      app = (
                          (top.get('application_key') if isinstance(top, dict) else None)
                          or (top.get('applicationKey') if isinstance(top, dict) else None)
                          or ev.get('application_key')
                          or ev.get('applicationKey')
                          or app
                      )
              except Exception:
                  pass
          if version:
              _pat = re.compile(r'^[A-Za-z0-9_][A-Za-z0-9_.\-+]*$')
              _v = str(version).strip()
              if _v == '<no value>' or not _pat.match(_v):
                  print(f"INFO: Ignoring invalid platform version from payload: {_v!r}")
                  version = ''
          if not version:
              print("‚ùå No platform version found in event payload")
              print("Event payload should contain:")
              print("- client_payload.data.application_version OR")  
              print("- client_payload.application_version OR")
              print("- data.application_version")
              raise SystemExit('No platform version found in repository_dispatch event payload. Cannot proceed without explicit version.')
          geh = os.environ.get('GITHUB_ENV')
          if geh:
              with open(geh, 'a', encoding='utf-8') as ef:
                  ef.write(f"RESOLVED_PV={version}\n")
                  ef.write(f"APPTRUST_APPLICATION={app}\n")
          print(f"Resolved platform version: {version}")
          PY

      - name: Fetch platform content from AppTrust
        if: env.SKIP != 'true'
        env:
          JFROG_URL: ${{ vars.JFROG_URL }}
          JF_OIDC_TOKEN: ${{ env.JF_OIDC_TOKEN }}
        run: |
          set -euo pipefail
          echo "üîç Fetching platform content for ${APPTRUST_APPLICATION}@${RESOLVED_PV}"
          
          if [[ -z "${JF_OIDC_TOKEN:-}" ]]; then
            echo "‚ùå JF_OIDC_TOKEN is not set. OIDC token extraction step may have failed." >&2
            exit 1
          fi
          echo "‚úÖ JF_OIDC_TOKEN is available (length: ${
          
          URL="${JFROG_URL%/}/apptrust/api/v1/applications/${APPTRUST_APPLICATION}/versions/${RESOLVED_PV}/content?include=releasables,sources"
          echo "üì° API URL: $URL"
          
          TEMP_RESPONSE=$(mktemp)
          CODE=$(curl -sS -o "$TEMP_RESPONSE" -w "%{http_code}" \
            -H "Authorization: Bearer ${JF_OIDC_TOKEN}" \
            -H "Accept: application/json" \
            "$URL")
          
          echo "üìä Content fetch HTTP ${CODE}"
          
          if [[ "$CODE" -ge 200 && "$CODE" -lt 300 ]]; then
            echo "‚úÖ Successfully fetched platform content"
            cp "$TEMP_RESPONSE" platform_components.json
          else
            echo "‚ùå Failed to fetch platform content (HTTP $CODE)"
            echo "Response body:"
            cat "$TEMP_RESPONSE"
            echo ""
            echo "üîç Debugging info:"
            echo "  Application: ${APPTRUST_APPLICATION}"
            echo "  Version: ${RESOLVED_PV}"
            echo "  Token prefix: ${JF_OIDC_TOKEN:0:10}..."
            rm -f "$TEMP_RESPONSE"
            exit 1
          fi
          
          rm -f "$TEMP_RESPONSE"

      - name: Pin image tags in values.yaml
        if: env.SKIP != 'true'
        run: |
          python - << 'PY'
          import json, yaml, os
          try:
              with open('platform_components.json', 'r', encoding='utf-8') as f:
                  raw = json.load(f)
          except Exception:
              raw = {}
          comp = raw if isinstance(raw, dict) else {}
          releasables = []
          if isinstance(raw, list):
              releasables = raw
          elif isinstance(comp.get('releasables'), list):
              releasables = comp.get('releasables')

          app_to_values_key={
            'bookverse-inventory':'inventory',
            'bookverse-recommendations':'recommendations',
            'bookverse-checkout':'checkout',
            'bookverse-web':'web',
          }

          def coalesce_keys(obj, *keys):
              for k in keys:
                  if isinstance(obj, dict) and k in obj and obj[k] not in (None, ''):
                      return obj[k]
              return None

          versions_by_app={}
          _sources = comp.get('sources') if isinstance(comp, dict) else None
          src = _sources.get('versions') if isinstance(_sources, dict) else None
          if isinstance(src, list):
              for entry in src:
                  ak = coalesce_keys(entry, 'application_key','applicationKey','application') or ''
                  ver = coalesce_keys(entry, 'application_version','applicationVersion','version')
                  if ak and ver:
                      versions_by_app[str(ak)]=str(ver)

          versions_by_service={}
          if isinstance(releasables, list):
              for item in releasables:
                  if not isinstance(item, dict):
                      continue
                  if item.get('package_type') != 'docker' or item.get('releasable_type') != 'package_version':
                      continue
                  name = str(item.get('name') or '').strip()
                  ver = str(item.get('version') or '').strip()
                  if name and ver:
                      versions_by_service[name] = ver

          def update_file(path):
            y=yaml.safe_load(open(path)) or {}
            plat_ver = coalesce_keys(comp, 'version','platform_version') if isinstance(comp, dict) else None
            if plat_ver is not None:
                y.setdefault('platform', {})['version']=str(plat_ver)
            
            print(f"üìã Platform version: {plat_ver}")
            print(f"üìã Application versions found: {versions_by_app}")
            print(f"üìã Docker image tags found: {versions_by_service}")

            print("üîç Available application versions from platform bundle:")
            for app_key, version in versions_by_app.items():
                print(f"  {app_key}: {version}")
            
            print("üîç Available docker tags from releasables:")
            for svc_name, tag in versions_by_service.items():
                print(f"  {svc_name}: {tag}")
            
            print("‚ö†Ô∏è  TEMPORARY: Using docker image versions due to platform application bugs")
            print("   - sources.versions not calculated correctly")
            print("   - SHA-based versions accepted as valid (semver check disabled)")
            print("   Both issues will be fixed in platform application")
            
            service_to_app = {
                'inventory': 'bookverse-inventory',
                'recommendations': 'bookverse-recommendations', 
                'checkout': 'bookverse-checkout',
                'web': 'bookverse-web'
            }
            
            required_services = ['inventory', 'recommendations', 'checkout', 'web']
            missing_services = []
            
            for svc in required_services:
                if svc not in versions_by_service:
                    missing_services.append(svc)
            
            if missing_services:
                print(f"‚ùå ERROR: Missing docker image versions:")
                for svc in missing_services:
                    print(f"  - Missing: {svc}")
                print(f"Available docker images: {list(versions_by_service.keys())}")
                print(f"Platform bundle must contain docker image versions for all services.")
                raise SystemExit("Platform bundle incomplete - missing docker image versions")
            
            print("üìã Docker image version types:")
            for svc in required_services:
                version = versions_by_service[svc]
                version_type = "SHA-based" if version.startswith('sha256__') else "Semantic"
                print(f"  {svc}: {version} ({version_type})")
            
            print("‚úÖ All required docker image versions found in platform bundle")
            
            print("üê≥ DOCKER IMAGE PINNING RESULTS:")
            print("=" * 60)
            
            for app_key, values_key in app_to_values_key.items():
                if values_key == 'recommendations':
                    rec_version = versions_by_service.get('recommendations')
                    worker_version = versions_by_service.get('recommendations-worker', rec_version)
                    
                    rec_repo = ((y.get('recommendations') or {}).get('repository')) or f"apptrustswampupc.jfrog.io/{values_key}"
                    worker_repo = (((y.get('recommendations') or {}).get('worker') or {}).get('repository')) or f"apptrustswampupc.jfrog.io/{values_key}-worker"
                    
                    y.setdefault('recommendations', {})['tag']=str(rec_version)
                    y.setdefault('recommendations', {}).setdefault('worker', {})['tag']=str(worker_version)
                    
                    print(f"üìå {values_key}:")
                    print(f"   Source: Docker image version from platform bundle (temporary workaround)")
                    print(f"   Docker Image: {rec_repo}:{rec_version}")
                    print(f"üìå {values_key}.worker:")
                    print(f"   Source: Docker image version from platform bundle (worker-specific or shared)")
                    print(f"   Docker Image: {worker_repo}:{worker_version}")
                else:
                    docker_version = versions_by_service[values_key]
                    
                    repo = ((y.get(values_key) or {}).get('repository')) or f"apptrustswampupc.jfrog.io/{values_key}"
                    
                    y.setdefault(values_key, {})['tag']=str(docker_version)
                    
                    print(f"üìå {values_key}:")
                    print(f"   Source: Docker image version from platform bundle (temporary workaround)")
                    print(f"   Docker Image: {repo}:{docker_version}")
            
            print("=" * 60)

            with open(path,'w') as f:
                yaml.safe_dump(y, f, sort_keys=False)


          update_file('charts/platform/values.yaml')
          PY

      - name: Commit and push changes
        if: env.SKIP != 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add charts/platform/values.yaml platform_components.json || true
          if git diff --cached --quiet; then
            echo "No changes to commit"
            exit 0
          fi
          msg="chore(platform): update k8s pins for platform ${RESOLVED_PV}"
          git commit -m "$msg"
          git push

      - name: Setup Helm
        if: env.SKIP != 'true'
        uses: azure/setup-helm@v4
        with:
          version: v3.14.4

      - name: Helm lint and package
        if: env.SKIP != 'true'
        run: |
          helm lint charts/platform
          mkdir -p dist
          helm package charts/platform --destination dist

  summarize_pins:
    runs-on: ubuntu-latest
    needs: pin_and_package
    steps:
      - uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0
      - name: Ensure latest main
        run: |
          git fetch origin main --depth=1
          git checkout -qf origin/main
      - name: Generate job summary
        env:
          SKIP: ${{ needs.pin_and_package.outputs.SKIP || '' }}
          SKIP_REASON: ${{ needs.pin_and_package.outputs.SKIP_REASON || '' }}
        run: |
          python - << 'PY'
          import os, json, yaml

          skip = os.environ.get('SKIP', '').lower() == 'true'
          skip_reason = os.environ.get('SKIP_REASON', '')

          if skip:
              sections = []
              sections.append("
              sections.append("")
              sections.append("The Helm chart update process was skipped because:")
              sections.append(f"**{skip_reason}**")
              sections.append("")
              sections.append("
              sections.append("- Event must be a `repository_dispatch` with action `release_completed`")
              sections.append("- Stage must be `PROD`")
              sections.append("- Application key must be `bookverse-platform`")
              sections.append("")
              
              payload = {}
              ev_path=os.environ.get('GITHUB_EVENT_PATH')
              if ev_path and os.path.exists(ev_path):
                  try:
                      ev=json.load(open(ev_path))
                  except Exception:
                      ev={}
                  cp=ev.get('client_payload') if isinstance(ev.get('client_payload'), dict) else {}
                  data=cp.get('data') if isinstance(cp.get('data'), dict) else {}
                  payload={
                      'application_key': data.get('application_key') or data.get('applicationKey') or cp.get('application_key') or cp.get('applicationKey') or '',
                      'application_version': data.get('application_version') or data.get('applicationVersion') or cp.get('application_version') or cp.get('applicationVersion') or '',
                      'stage': (data.get('stage') or cp.get('stage') or ev.get('stage') or '').upper()
                  }
              
              sections.append("
              sections.append("```json")
              sections.append(json.dumps(payload, indent=2, ensure_ascii=False))
              sections.append("```")
              
          else:
              def read_yaml(path):
                  try:
                      with open(path, 'r', encoding='utf-8') as f:
                          return yaml.safe_load(f) or {}
                  except Exception:
                      return {}

              def coalesce(obj, *keys):
                  for k in keys:
                      if isinstance(obj, dict) and k in obj and obj[k] not in (None, ''):
                          return obj[k]
                  return None

              payload = {}
              ev_path=os.environ.get('GITHUB_EVENT_PATH')
              if ev_path and os.path.exists(ev_path):
                  try:
                      ev=json.load(open(ev_path))
                  except Exception:
                      ev={}
                  cp=ev.get('client_payload') if isinstance(ev.get('client_payload'), dict) else {}
                  data=cp.get('data') if isinstance(cp.get('data'), dict) else {}
                  payload={
                      'application_key': data.get('application_key') or data.get('applicationKey') or cp.get('application_key') or cp.get('applicationKey') or '',
                      'application_version': data.get('application_version') or data.get('applicationVersion') or cp.get('application_version') or cp.get('applicationVersion') or '',
                      'stage': (data.get('stage') or cp.get('stage') or ev.get('stage') or '').lower()
                  }

              try:
                  with open('platform_components.json','r',encoding='utf-8') as f:
                      raw = json.load(f)
              except Exception:
                  raw = {}
              comp = raw if isinstance(raw, dict) else {}
              
              app_versions = {}
              sources = comp.get('sources', [])
              if isinstance(sources, list):
                  for source in sources:
                      if isinstance(source, dict) and source.get('type') == 'release_bundle':
                          rb = source.get('release_bundle', {})
                          if isinstance(rb, dict):
                              name = rb.get('name', '')
                              version = rb.get('version', '')
                              if name and version:
                                  app_versions[name] = version
              
              docker_tags = {}
              releasables = comp.get('releasables', [])
              if isinstance(releasables, list):
                  for item in releasables:
                      if not isinstance(item, dict):
                          continue
                      if item.get('package_type') != 'docker' or item.get('releasable_type') != 'package_version':
                          continue
                      name = str(item.get('name') or '').strip()
                      ver = str(item.get('version') or '').strip()
                      if name and ver:
                          docker_tags[name] = ver

              y = read_yaml('charts/platform/values.yaml')
              def get_tag(doc, svc):
                  if svc == 'recommendations.worker':
                      return (((doc.get('recommendations') or {}).get('worker') or {}).get('tag')) or ''
                  if svc == 'recommendations':
                      return ((doc.get('recommendations') or {}).get('tag')) or ''
                  return ((doc.get(svc) or {}).get('tag')) or ''

              sections = []
              sections.append("
              sections.append("")
              
              platform_version = comp.get('version', '')
              sections.append(f"**Platform Version:** `{platform_version}`")
              sections.append("")
              
              sections.append("
              sections.append("")
              
              app_to_service = {
                  'bookverse-inventory': 'inventory',
                  'bookverse-recommendations': 'recommendations', 
                  'bookverse-checkout': 'checkout',
                  'bookverse-web': 'web'
              }
              
              for app_name in sorted(app_versions.keys()):
                  app_version = app_versions[app_name]
                  service_name = app_to_service.get(app_name, app_name)
                  
                  if service_name == 'recommendations':
                      repo = (y.get('recommendations') or {}).get('repository', f'apptrustswampupc.jfrog.io/{service_name}')
                      tag = (y.get('recommendations') or {}).get('tag', 'unknown')
                      worker_repo = ((y.get('recommendations') or {}).get('worker') or {}).get('repository', f'apptrustswampupc.jfrog.io/{service_name}-worker')
                      worker_tag = ((y.get('recommendations') or {}).get('worker') or {}).get('tag', 'unknown')
                      
                      sections.append(f"- **{app_name}** `{app_version}` ‚Üí `{repo}:{tag}`")
                      sections.append(f"  - Source: Application version from platform bundle")
                      sections.append(f"- **{app_name}-worker** `{app_version}` ‚Üí `{worker_repo}:{worker_tag}`")
                      sections.append(f"  - Source: Application version from platform bundle (shared with main service)")
                  else:
                      repo = (y.get(service_name) or {}).get('repository', f'apptrustswampupc.jfrog.io/{service_name}')
                      tag = (y.get(service_name) or {}).get('tag', 'unknown')
                      sections.append(f"- **{app_name}** `{app_version}` ‚Üí `{repo}:{tag}`")
                      sections.append(f"  - Source: Application version from platform bundle")
              
              sections.append("")
              sections.append("
              sections.append(f"- `platform.version`: `{(y.get('platform') or {}).get('version','')}`")
              for svc in ['web','inventory','recommendations','checkout','recommendations.worker']:
                  tag = get_tag(y, svc)
                  sections.append(f"- `{svc}.tag`: `{tag}`")
              
              sections.append("")
              sections.append("
              sections.append("```json")
              sections.append(json.dumps(payload, indent=2, ensure_ascii=False))
              sections.append("```")

          summary = os.environ.get('GITHUB_STEP_SUMMARY','')
          text = "\n".join(sections) + "\n"
          if summary:
              with open(summary, 'a', encoding='utf-8') as f:
                  f.write(text)
          else:
              print(text)
          PY


