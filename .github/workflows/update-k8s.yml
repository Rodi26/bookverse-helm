name: Update K8s

run-name: Platform Release ${{ github.event.client_payload.data.application_version }}

on:
  repository_dispatch:
    types: [release_completed]
  workflow_dispatch:
    inputs:
      platform_version:
        description: 'Platform version to pin (optional)'
        required: false
        type: string
      build_number:
        description: 'Optional build number fallback'
        required: false
        type: string

permissions:
  contents: write
  id-token: write

jobs:
  pin_and_package:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: "Debug: Log repository_dispatch event (console only)"
        if: github.event_name == 'repository_dispatch' && github.event.action == 'release_completed'
        run: |
          echo "Full repository_dispatch event (console log):"
          cat "$GITHUB_EVENT_PATH"

      - name: "Gate: only process PROD repository_dispatch events"
        run: |
          python - << 'PY'
          import json, os
          path=os.environ.get('GITHUB_EVENT_PATH')
          data=json.load(open(path)) if path and os.path.exists(path) else {}
          event_name=os.environ.get('GITHUB_EVENT_NAME','')
          action = data.get('action') or os.environ.get('GITHUB_EVENT_ACTION','')
          stage=''
          if event_name=='repository_dispatch':
            cp = (data.get('client_payload') or {}) if isinstance(data.get('client_payload'), dict) else {}
            # Extract stage from JFrog webhook payload structure
            stage = (cp.get('data') or {}).get('stage') or cp.get('stage') or ''
            # Fallback to top-level payload fields (e.g., JFrog webhook forwarded as-is)
            if not stage:
              top = (data.get('data') or {})
              stage = (top.get('stage') if isinstance(top, dict) else '') or data.get('stage') or ''
            # Default to PROD for JFrog release_completed if stage missing
            if not stage and str(action).lower()=='release_completed':
              stage='PROD'
            
            # Debug logging
            print(f"Debug: event_name={event_name}, action={action!r}, stage={stage!r}")
            print(f"Debug: client_payload keys: {list(cp.keys()) if isinstance(cp, dict) else 'not dict'}")
            if isinstance(cp, dict) and 'data' in cp:
              data_payload = cp['data']
              print(f"Debug: client_payload.data keys: {list(data_payload.keys()) if isinstance(data_payload, dict) else 'not dict'}")
            
            if str(stage).lower()!='prod':
              with open(os.environ['GITHUB_ENV'],'a') as f:
                f.write('SKIP=true\n')
              print(f"Skipping repository_dispatch: action={action!r}, stage={stage!r}")
            else:
              print("Proceeding: repository_dispatch for PROD")
          else:
            # Allow non-dispatch events (e.g., manual workflow_dispatch)
            print(f"Proceeding: non-dispatch event={event_name}")
          PY

      # (Removed payload summary here; a concise summary is produced in summarize_pins.)

      - name: Setup JFrog CLI (OIDC)
        if: env.SKIP != 'true'
        uses: EyalDelarea/setup-jfrog-cli@swampUpAppTrust
        with:
          version: latest

      - name: Configure JFrog CLI
        if: env.SKIP != 'true'
        env:
          JFROG_URL: ${{ vars.JFROG_URL }}
        run: |
          jf c add --interactive=false --url "${JFROG_URL}" --access-token ""
          jf c show
          jf rt ping

      - name: Validate JFROG_ADMIN_TOKEN permissions
        if: env.SKIP != 'true'
        env:
          JFROG_URL: ${{ vars.JFROG_URL }}
          JFROG_ADMIN_TOKEN: ${{ secrets.JFROG_ADMIN_TOKEN }}
        run: |
          set -euo pipefail
          BASE="${JFROG_URL%/}"
          if [[ -z "${BASE}" ]]; then echo "Missing vars.JFROG_URL" >&2; exit 1; fi
          if [[ -z "${JFROG_ADMIN_TOKEN:-}" ]]; then
            echo "JFROG_ADMIN_TOKEN is not set. Configure this repo secret with AppTrust admin permissions." >&2
            exit 1
          fi
          URL="${BASE}/apptrust/api/v1/applications?limit=1"
          CODE=$(curl -sS -o /tmp/jf_token_check.json -w "%{http_code}" \
            -H "Authorization: Bearer ${JFROG_ADMIN_TOKEN}" \
            -H "Accept: application/json" \
            "$URL")
          if [[ "$CODE" != "200" ]]; then
            echo "AppTrust token check failed: HTTP ${CODE}" >&2
            (head -c 400 /tmp/jf_token_check.json || true) >&2
            exit 1
          fi
          echo "JFROG_ADMIN_TOKEN validation succeeded."

      - name: Set up Python
        if: env.SKIP != 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        if: env.SKIP != 'true'
        run: |
          python -m pip install --upgrade pip
          pip install PyYAML

      - name: Resolve platform version
        if: env.SKIP != 'true'
        id: resolve
        env:
          PLATFORM_APP: bookverse-platform
          JFROG_URL: ${{ vars.JFROG_URL }}
          JFROG_ACCESS_TOKEN: ${{ secrets.JFROG_ADMIN_TOKEN }}
        run: |
          python - << 'PY'
          import os, json, re, urllib.request, urllib.error, urllib.parse
          app=os.environ.get('PLATFORM_APP','bookverse-platform')
          version=''
          # Try resolve from repository_dispatch payload
          ev_path=os.environ.get('GITHUB_EVENT_PATH','')
          if not version and ev_path and os.path.exists(ev_path):
              try:
                  ev=json.load(open(ev_path))
                  cp=ev.get('client_payload') if isinstance(ev.get('client_payload'), dict) else {}
                  if isinstance(cp, dict):
                      data = cp.get('data') if isinstance(cp.get('data'), dict) else {}
                      # Support snake_case and camelCase keys
                      version = (
                          data.get('application_version')
                          or data.get('applicationVersion')
                          or cp.get('platform_version')
                          or cp.get('platformVersion')
                          or cp.get('application_version')
                          or cp.get('applicationVersion')
                          or version
                      )
                      app = (
                          data.get('application_key')
                          or data.get('applicationKey')
                          or cp.get('application_key')
                          or cp.get('applicationKey')
                          or app
                      )
                  if not version:
                      top=ev.get('data') if isinstance(ev.get('data'), dict) else {}
                      version = (
                          (top.get('application_version') if isinstance(top, dict) else None)
                          or (top.get('applicationVersion') if isinstance(top, dict) else None)
                          or ev.get('platform_version')
                          or ev.get('platformVersion')
                          or ev.get('application_version')
                          or ev.get('applicationVersion')
                          or version
                      )
                      app = (
                          (top.get('application_key') if isinstance(top, dict) else None)
                          or (top.get('applicationKey') if isinstance(top, dict) else None)
                          or ev.get('application_key')
                          or ev.get('applicationKey')
                          or app
                      )
              except Exception:
                  pass
          # Validate version format from payload; treat invalid or placeholder as missing to trigger fallback
          if version:
              _pat = re.compile(r'^[A-Za-z0-9_][A-Za-z0-9_.\-+]*$')
              _v = str(version).strip()
              if _v == '<no value>' or not _pat.match(_v):
                  print(f"INFO: Ignoring invalid platform version from payload: {_v!r}")
                  version = ''
          if not version:
              # Fallback: try latest RELEASED; if that fails, try latest regardless of status via AppTrust API
              base=os.environ.get('JFROG_URL','').rstrip('/')
              token=os.environ.get('JFROG_ACCESS_TOKEN','')
              if not base or not token:
                  raise SystemExit('Missing JFROG_URL or JFROG_ACCESS_TOKEN')
              def http_get_json(url: str):
                  headers={"Authorization": f"Bearer {token}", "Accept": "application/json"}
                  req=urllib.request.Request(url, headers=headers)
                  try:
                      with urllib.request.urlopen(req, timeout=30) as resp:
                          raw = resp.read().decode('utf-8') or '{}'
                      try:
                          return json.loads(raw)
                      except Exception:
                          return {}
                  except urllib.error.HTTPError as e:
                      body = ''
                      try:
                          body = e.read().decode('utf-8', 'ignore')
                      except Exception:
                          pass
                      print(f"WARN: GET {url} -> {e.code} {body[:200]}")
                      return {}
              base_q = f"{base}/apptrust/api/v1/applications/{urllib.parse.quote(app)}/versions?limit=1"
              payload = http_get_json(base_q + "&release_status=RELEASED") or http_get_json(base_q)
              if isinstance(payload, dict):
                  candidates = payload.get('results') or payload.get('data') or payload.get('items') or payload.get('versions') or []
              else:
                  candidates = payload
              # Pick first candidate with a valid version string according to allowed format
              def pick_valid(cands):
                  pattern = re.compile(r'^[A-Za-z0-9_][A-Za-z0-9_.\-+]*$')
                  for it in (cands or []):
                      val = it.get('version') or it.get('name') or ''
                      if val is None:
                          continue
                      v = str(val).strip()
                      if not v or v == '<no value>':
                          continue
                      if not pattern.match(v):
                          continue
                      return v
                  return ''
              version = pick_valid(candidates)
              if not version:
                  raise SystemExit('Unable to resolve a valid platform version from AppTrust')
          geh = os.environ.get('GITHUB_ENV')
          if geh:
              with open(geh, 'a', encoding='utf-8') as ef:
                  ef.write(f"RESOLVED_PV={version}\n")
                  ef.write(f"APPTRUST_APPLICATION={app}\n")
          print(f"Resolved platform version: {version}")
          PY

      - name: Fetch platform content from AppTrust
        if: env.SKIP != 'true'
        env:
          JFROG_URL: ${{ vars.JFROG_URL }}
          JFROG_ACCESS_TOKEN: ${{ secrets.JFROG_ADMIN_TOKEN }}
        run: |
          set -euo pipefail
          echo "Fetching platform content for ${APPTRUST_APPLICATION}@${RESOLVED_PV}"
          URL="${JFROG_URL%/}/apptrust/api/v1/applications/${APPTRUST_APPLICATION}/versions/${RESOLVED_PV}/content?include=releasables,sources"
          CODE=$(curl -sS -o platform_components.json -w "%{http_code}" \
            -H "Authorization: Bearer ${JFROG_ACCESS_TOKEN}" \
            -H "Accept: application/json" \
            "$URL")
          echo "Content fetch HTTP ${CODE}"

      - name: Pin image tags in values.yaml
        if: env.SKIP != 'true'
        run: |
          python - << 'PY'
          import json, yaml, os
          # Load content and normalize shapes
          try:
              with open('platform_components.json', 'r', encoding='utf-8') as f:
                  raw = json.load(f)
          except Exception:
              raw = {}
          comp = raw if isinstance(raw, dict) else {}
          releasables = []
          if isinstance(raw, list):
              releasables = raw
          elif isinstance(comp.get('releasables'), list):
              releasables = comp.get('releasables')

          # Known app->values key mapping
          app_to_values_key={
            'bookverse-inventory':'inventory',
            'bookverse-recommendations':'recommendations',
            'bookverse-checkout':'checkout',
            'bookverse-web':'web',
          }

          def coalesce_keys(obj, *keys):
              for k in keys:
                  if isinstance(obj, dict) and k in obj and obj[k] not in (None, ''):
                      return obj[k]
              return None

          # 1) Extract component versions from sources.versions (preferred for app keys)
          versions_by_app={}
          _sources = comp.get('sources') if isinstance(comp, dict) else None
          src = _sources.get('versions') if isinstance(_sources, dict) else None
          if isinstance(src, list):
              for entry in src:
                  ak = coalesce_keys(entry, 'application_key','applicationKey','application') or ''
                  ver = coalesce_keys(entry, 'application_version','applicationVersion','version')
                  if ak and ver:
                      versions_by_app[str(ak)]=str(ver)

          # 2) Extract versions by service name from releasables (authoritative for image tags)
          versions_by_service={}
          if isinstance(releasables, list):
              for item in releasables:
                  if not isinstance(item, dict):
                      continue
                  if item.get('package_type') != 'docker' or item.get('releasable_type') != 'package_version':
                      continue
                  name = str(item.get('name') or '').strip()
                  ver = str(item.get('version') or '').strip()
                  if name and ver:
                      versions_by_service[name] = ver

          # Helper to write tags into values
          def update_file(path):
            y=yaml.safe_load(open(path)) or {}
            # Set platform version if present in content
            plat_ver = coalesce_keys(comp, 'version','platform_version') if isinstance(comp, dict) else None
            if plat_ver is not None:
                y.setdefault('platform', {})['version']=str(plat_ver)

            # Apply service-name versions (preferred)
            name_map = {
              'web': ('web', None),
              'inventory': ('inventory', None),
              'recommendations': ('recommendations', None),
              'checkout': ('checkout', None),
              'recommendations-worker': ('recommendations', 'worker'),
            }
            for svc_name, (root, child) in name_map.items():
                ver = versions_by_service.get(svc_name)
                if ver:
                    if child:
                        y.setdefault(root, {}).setdefault(child, {})['tag']=str(ver)
                    else:
                        y.setdefault(root, {})['tag']=str(ver)

            # Fallback: Map app keys to values keys if service-name mapping missing
            for app_key, values_key in app_to_values_key.items():
                if values_key == 'recommendations':
                    # top-level recommendations
                    if not ((y.get('recommendations') or {}).get('tag')):
                        ver = versions_by_app.get(app_key)
                        if ver:
                            y.setdefault('recommendations', {})['tag']=str(ver)
                    # nested worker, only if not already set
                    if not (((y.get('recommendations') or {}).get('worker') or {}).get('tag')):
                        verw = versions_by_service.get('recommendations-worker') or versions_by_app.get(app_key)
                        if verw:
                            y.setdefault('recommendations', {}).setdefault('worker', {})['tag']=str(verw)
                    continue
                # other services
                if not ((y.get(values_key) or {}).get('tag')):
                    ver = versions_by_app.get(app_key)
                    if ver:
                        y.setdefault(values_key, {})['tag']=str(ver)

            with open(path,'w') as f:
                yaml.safe_dump(y, f, sort_keys=False)

            # No summary output here; keep summary concise in summarize_pins

          # Update single values file only
          update_file('charts/platform/values.yaml')
          PY

      - name: Commit and push changes
        if: env.SKIP != 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add charts/platform/values.yaml platform_components.json || true
          if git diff --cached --quiet; then
            echo "No changes to commit"
            exit 0
          fi
          msg="chore(platform): update k8s pins for platform ${RESOLVED_PV}"
          git commit -m "$msg"
          git push

      - name: Setup Helm
        if: env.SKIP != 'true'
        uses: azure/setup-helm@v4
        with:
          version: v3.14.4

      - name: Helm lint and package
        if: env.SKIP != 'true'
        run: |
          helm lint charts/platform
          mkdir -p dist
          helm package charts/platform --destination dist

  summarize_pins:
    runs-on: ubuntu-latest
    needs: pin_and_package
    steps:
      - uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0
      - name: Ensure latest main
        run: |
          git fetch origin main --depth=1
          git checkout -qf origin/main
      - name: Summarize pinned image tags
        env:
          SKIP: ${{ needs.pin_and_package.outputs.SKIP || '' }}
        run: |
          python - << 'PY'
          import os, json, yaml

          def read_yaml(path):
              try:
                  with open(path, 'r', encoding='utf-8') as f:
                      return yaml.safe_load(f) or {}
              except Exception:
                  return {}

          def coalesce(obj, *keys):
              for k in keys:
                  if isinstance(obj, dict) and k in obj and obj[k] not in (None, ''):
                      return obj[k]
              return None

          # 1) Payload (concise)
          payload = {}
          ev_path=os.environ.get('GITHUB_EVENT_PATH')
          if ev_path and os.path.exists(ev_path):
              try:
                  ev=json.load(open(ev_path))
              except Exception:
                  ev={}
              cp=ev.get('client_payload') if isinstance(ev.get('client_payload'), dict) else {}
              data=cp.get('data') if isinstance(cp.get('data'), dict) else {}
              payload={
                  'application_key': data.get('application_key') or data.get('applicationKey') or cp.get('application_key') or cp.get('applicationKey') or '',
                  'application_version': data.get('application_version') or data.get('applicationVersion') or cp.get('application_version') or cp.get('applicationVersion') or '',
                  'stage': (data.get('stage') or cp.get('stage') or ev.get('stage') or '').lower()
              }

          # 2) Extracted component versions from platform_components.json
          versions_by_app = {}
          versions_by_service = {}
          try:
              with open('platform_components.json','r',encoding='utf-8') as f:
                  raw = json.load(f)
          except Exception:
              raw = {}
          comp = raw if isinstance(raw, dict) else {}
          releasables = []
          if isinstance(raw, list):
              releasables = raw
          elif isinstance(comp.get('releasables'), list):
              releasables = comp.get('releasables')
          _sources = comp.get('sources') if isinstance(comp, dict) else None
          src = _sources.get('versions') if isinstance(_sources, dict) else None
          if isinstance(src, list):
              for entry in src:
                  ak = coalesce(entry, 'application_key','applicationKey','application')
                  ver = coalesce(entry, 'application_version','applicationVersion','version')
                  if ak and ver:
                      versions_by_app[str(ak)] = str(ver)
          if isinstance(releasables, list):
              for item in releasables:
                  if not isinstance(item, dict):
                      continue
                  if item.get('package_type') != 'docker' or item.get('releasable_type') != 'package_version':
                      continue
                  name = str(item.get('name') or '').strip()
                  ver = str(item.get('version') or '').strip()
                  if name and ver:
                      versions_by_service[name] = ver

          # 3) Pinned tags from values.yaml
          y = read_yaml('charts/platform/values.yaml')
          def get_tag(doc, svc):
              if svc == 'recommendations.worker':
                  return (((doc.get('recommendations') or {}).get('worker') or {}).get('tag')) or ''
              if svc == 'recommendations':
                  return ((doc.get('recommendations') or {}).get('tag')) or ''
              return ((doc.get(svc) or {}).get('tag')) or ''

          sections = []
          sections.append("### Payload")
          sections.append("""```json\n%s\n```""" % json.dumps(payload, indent=2, ensure_ascii=False))

          sections.append("### Extracted components")
          if versions_by_service:
              for k in sorted(versions_by_service.keys()):
                  sections.append(f"- {k}: {versions_by_service[k]}")
          elif versions_by_app:
              for k in sorted(versions_by_app.keys()):
                  sections.append(f"- {k}: {versions_by_app[k]}")
          else:
              sections.append("- (none found)")

          sections.append("### Pinned image tags")
          sections.append(f"platform.version = {(y.get('platform') or {}).get('version','')}")
          for svc in ['web','inventory','recommendations','checkout','recommendations.worker']:
              sections.append(f"- {svc}: tag={get_tag(y, svc)}")

          summary = os.environ.get('GITHUB_STEP_SUMMARY','')
          text = "\n".join(sections) + "\n"
          if summary:
              with open(summary, 'a', encoding='utf-8') as f:
                  f.write(text)
          else:
              print(text)
          PY


